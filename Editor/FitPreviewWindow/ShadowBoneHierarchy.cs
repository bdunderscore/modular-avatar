#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;
using nadena.dev.modular_avatar.core;
using nadena.dev.ndmf;
using UnityEditor;
using UnityEngine;
using UnityEngine.Animations;
using UnityEngine.SceneManagement;
using VRC.Dynamics;
using VRC.SDK3.Dynamics.PhysBone.Components;
using IConstraint = UnityEngine.Animations.IConstraint;
using Object = UnityEngine.Object;

namespace nadena.dev.modular_avatar.editor.fit_preview
{
    /**
     * The shadow bone hierarchy is used to allow the user to manipulate the bones of their avatar
     * after preview processing, without impacting the original avatar. It's important that any
     * changes to either the original bones, or proxy bones (such as those generated by Scale Adjuster)
     * are reflected here as well.
     * 
     * As such, we track for each shadow bone:
     * * The proxy-side bone it originated from
     * * The bone in the original avatar it originated from (possibly the same as the proxy-side bone)
     * * The parent of the original avatar bone
     * 
     * Generally, we intend to maintain a particular offset pose from the proxy bone. This means tracking
     * the local transform of the proxy bone, as of the prior frame; if it changed, we should reflect that
     * change in the shadow bone. Otherwise, we update the relative pose with any changes the user made to
     * the shadow bone.
     * 
     * Structure changes:
     * A bone's parent is considered part of its identity; if the hierarchy changes, we will treat this
     * as a new bone, to keep things simple.
     */
    internal class ShadowBoneHierarchy : IDisposable
    {
        public GameObject Root { get; }
        public bool DynamicsEnabled { get; set; } = true;
        private readonly Scene _scene;

        // (parent, child) => child boneInfo
        private readonly Dictionary<Transform, BoneInfo> _sourceToShadowMap = new();
        private readonly Dictionary<Transform, BoneInfo> _shadowObjMap = new();
        private List<BoneInfo>? _updateOrder;

        private bool _delayedUpdatePending;

        private readonly MethodInfo? _pbOnStart = AccessTools.Method(typeof(VRCPhysBoneBase), "Start");
        private readonly MethodInfo? _pbOnEnable = AccessTools.Method(typeof(VRCPhysBoneBase), "OnEnable");
        private readonly MethodInfo? _pbOnDisable = AccessTools.Method(typeof(VRCPhysBoneBase), "OnDisable");
        
        private readonly MethodInfo? _colliderOnEnable = AccessTools.Method(typeof(VRCPhysBoneColliderBase), "OnEnable");
        private readonly MethodInfo? _colliderOnDisable = AccessTools.Method(typeof(VRCPhysBoneColliderBase), "OnDisable");

        private void ScheduleDelayedUpdate()
        {
            if (_delayedUpdatePending) return;
            _delayedUpdatePending = true;
            EditorApplication.delayCall += DelayedUpdate;
        }
        
        private static Transform ResolveParent(Transform t)
        {
            var mama = t.GetComponentInParent<ModularAvatarMergeArmature>();
            if (mama != null)
            {
                var mamaRoot = mama.mergeTarget.Get(mama);

                if (mamaRoot == null)
                {
                    return t.parent;
                }

                if (mama.transform == t)
                {
                    return mamaRoot.transform;
                }

                if (mamaRoot != null)
                {
                    var baseParent = ResolveParent(t.parent);
                    var corresponding = mama.FindCorrespondingBone(t, baseParent);
                    if (corresponding != null) return corresponding;
                }
            }

            return t.parent;
        }
        
        private static Transform? ResolveOriginalBone(Transform? t)
        {
            if (t == null) return null;
            
            var reg = ObjectRegistry.GetReference(t.gameObject);
            var origObject = reg.Object as GameObject;
            if (origObject == null || origObject.transform == t) return t;

            return origObject.transform;
        }

        public ShadowBoneHierarchy(GameObject root, Scene scene)
        {
            Root = root;
            _scene = scene;
        }

        private BoneInfo? GetOrCreateBoneInfo(Transform? t)
        {
            var refBone = ResolveOriginalBone(t);
            if (refBone == null) return null;
            BoneInfo? parentInfo = null;
            var parent = ResolveParent(t);
            if (refBone.gameObject != Root && parent != null)
            {
                parentInfo = GetOrCreateBoneInfo(parent);
            }

            if (_sourceToShadowMap.TryGetValue(refBone, out var info))
            {
                return info;
            }

            ScheduleDelayedUpdate();

            info = new BoneInfo(_scene, refBone, t, parentInfo);
            _sourceToShadowMap[refBone] = info;
            _shadowObjMap[info.FinalRender.transform] = info;
            info.OnDestroy += () =>
            {
                if (t != null)
                {
                    foreach (var pb in t.GetComponentsInChildren<VRCPhysBoneBase>())
                    {
                        _pbOnDisable?.Invoke(pb, new object[] { });
                    }

                    foreach (var coll in t.GetComponentsInChildren<VRCPhysBoneColliderBase>())
                    {
                        _colliderOnDisable?.Invoke(coll, new object[] { });
                    }
                }

                _sourceToShadowMap.Remove(refBone);
                _shadowObjMap.Remove(info.FinalRender.transform);
                _updateOrder = null;
            };
            _updateOrder = null;

            return info;
        }

        public Transform GetOrCreateTransform(Transform t)
        {
            if (t == null) return t;

            var info = GetOrCreateBoneInfo(t);
            info.AddRef();

            return info.FinalRender;
        }

        public void ReleaseTransform(Transform t)
        {
            if (_shadowObjMap.TryGetValue(t, out var info))
            {
                info.RemoveRef();
                if (info.RefCount == 0)
                {
                    ScheduleDelayedUpdate();
                }
            }
        }

        public void Update()
        {
            if (DynamicsEnabled)
            {
                UpdatePBConfigs();
                TransferConstraintData();
            }

            if (_updateOrder == null)
            {
                _updateOrder = _shadowObjMap.Values.OrderBy(b => b.Depth).ToList();
            }

            foreach (var bone in _updateOrder)
            {
                bone.Update();
            }
        }

        private readonly HashSet<BoneInfo> pbControlledBones = new();
        private readonly Dictionary<VRCPhysBone, VRCPhysBone> _pbProxyToOriginal = new();
        private readonly Dictionary<VRCPhysBoneColliderBase, VRCPhysBoneColliderBase> _pbOriginalToProxyColliders = new();
        private readonly List<Transform> _pbExcludedControlBones = new();
        
        private void DelayedUpdate()
        {
            var gc = InitialMark();

            ConfigurePhysBones(gc);
            ConfigureConstraints(gc);
            SweepGC(gc);

            _delayedUpdatePending = false;
        }

        private void ConfigureConstraints(GC gc)
        {
            ResetConstraints();
            if (!DynamicsEnabled) return;

            List<ConstraintSource> sources = new();
            foreach (var unityConstraint in Root.GetComponentsInChildren<IConstraint>())
            {
                var constrainedBone = GetOrCreateBoneInfo(((Component)unityConstraint).transform);
                var newConstraint = constrainedBone.Control.gameObject.AddComponent(unityConstraint.GetType());
                _constrainedBones.Add(constrainedBone);
                _unityConstraints.Add((unityConstraint, (IConstraint)newConstraint));
                gc.MarkBone(constrainedBone);
            }

            foreach (var vrcConstraint in Root.GetComponentsInChildren<VRCConstraintBase>())
            {
                var constrainedBone = GetOrCreateBoneInfo(vrcConstraint.transform);
                var newConstraint = constrainedBone.Control.gameObject.AddComponent(vrcConstraint.GetType());
                _constrainedBones.Add(constrainedBone);
                _vrcConstraints.Add((vrcConstraint, (VRCConstraintBase)newConstraint));
                gc.MarkBone(constrainedBone);
            }

            TransferConstraintData(gc);
        }

        private void TransferConstraintData(GC? gc = null)
        {
            List<ConstraintSource> sources = new();
            foreach (var (src, dst) in _unityConstraints)
            {
                var srcObj = (Object)src;
                var dstObj = (Object)dst;

                if (srcObj == null || dstObj == null) continue;

                EditorUtility.CopySerialized(srcObj, dstObj);

                sources.Clear();
                dst.GetSources(sources);
                for (var i = 0; i < sources.Count; i++)
                {
                    var source = sources[i];
                    var boneInfo = GetOrCreateBoneInfo(sources[i].sourceTransform);
                    source.sourceTransform = boneInfo?.Control;
                    sources[i] = source;

                    if (gc != null && boneInfo != null) gc.MarkBone(boneInfo);
                }

                dst.SetSources(sources);
            }

            foreach (var (src, dst) in _vrcConstraints)
            {
                if (src == null || dst == null) continue;
                EditorUtility.CopySerialized(src, dst);

                var vrcSources = dst.Sources;
                for (var i = 0; i < vrcSources.Count; i++)
                {
                    var source = vrcSources[i];
                    var boneInfo = GetOrCreateBoneInfo(source.SourceTransform);
                    source.SourceTransform = boneInfo?.Control;
                    vrcSources[i] = source;

                    if (gc != null && boneInfo != null) gc.MarkBone(boneInfo);
                }

                // Despite being a list, this is somehow a struct and needs to be written back.
                dst.Sources = vrcSources;
            }
        }

        private readonly HashSet<BoneInfo> _constrainedBones = new();
        private readonly List<(IConstraint, IConstraint)> _unityConstraints = new();
        private readonly List<(VRCConstraintBase, VRCConstraintBase)> _vrcConstraints = new();

        private void ResetConstraints()
        {
            foreach (var (_, constraint) in _vrcConstraints)
            {
                Object.DestroyImmediate(constraint);
            }

            foreach (var (_, constraint) in _unityConstraints)
            {
                Object.DestroyImmediate((Component)constraint);
            }

            foreach (var constrainedBone in _constrainedBones)
            {
                constrainedBone.ResetPose();
            }

            _vrcConstraints.Clear();
            _unityConstraints.Clear();
            _constrainedBones.Clear();
        }

        private void ConfigurePhysBones(GC gc)
        {
            ResetPB();
            if (!DynamicsEnabled) return;
            
            _pbExcludedControlBones.Clear();
            _pbExcludedControlBones.AddRange(_shadowObjMap.Values
                .Where(b => b.PBExcluded)
                .Select(b => b.Control)
            );
            foreach (var pb in Root.GetComponentsInChildren<VRCPhysBone>())
            {
                ConfigurePhysBone(gc, pb);
            }

            if (_pbProxyToOriginal.Count > 0)
            {
                EditorApplication.update += UpdatePBConfigs;
            }
        }

        private void ConfigurePhysBone(GC gc, VRCPhysBone pb)
        {
            if (!pb.isActiveAndEnabled) return;
            
            var root = pb.rootTransform != null ? pb.rootTransform : pb.transform;
            var excluded = pb.ignoreTransforms.ToHashSet();
            var rootInfo = GetOrCreateBoneInfo(root);
            var pbHolderInfo = GetOrCreateBoneInfo(pb.transform);
            gc.MarkBone(rootInfo);
            gc.MarkBone(pbHolderInfo);

            foreach (var t in root.GetComponentsInChildren<Transform>())
            {
                if (!excluded.Contains(t))
                {
                    var info = GetOrCreateBoneInfo(t);
                    pbControlledBones.Add(info);
                    gc.MarkBone(info);
                }
            }

            var proxyPB = pbHolderInfo.Control.gameObject.AddComponent<VRCPhysBone>();
            EditorUtility.CopySerialized(pb, proxyPB);

            proxyPB.rootTransform = rootInfo.Control;
            proxyPB.ignoreTransforms = pb.ignoreTransforms
                .Select(t => GetOrCreateBoneInfo(t)?.Control)
                .Where(t => t != null)
                .Union(_pbExcludedControlBones.Where(b => b != root))
                .ToList();

            List<VRCPhysBoneColliderBase> colliders = new();
            foreach (var c in pb.colliders ?? new List<VRCPhysBoneColliderBase>())
            {
                if (c == null) continue;
                if (!c.isActiveAndEnabled) continue;
                if (_pbOriginalToProxyColliders.TryGetValue(c, out var collider) && collider != null)
                {
                    colliders.Add(collider);
                    continue;
                }

                var colliderHolder = GetOrCreateBoneInfo(c.transform);
                var colliderRoot = c.rootTransform != null ? c.rootTransform : c.transform;
                var colliderInfo = GetOrCreateBoneInfo(colliderRoot);
                gc.MarkBone(colliderInfo);
                collider = colliderHolder.Control.gameObject.AddComponent<VRCPhysBoneCollider>();
                EditorUtility.CopySerialized(c, collider);
                collider.rootTransform = colliderInfo.Control;
                colliders.Add(collider);

                _colliderOnEnable?.Invoke(collider, new object[] { });
                
                _pbOriginalToProxyColliders[c] = collider;
            }
            proxyPB.colliders = colliders;

            // Force initialize in edit mode
            _pbOnStart?.Invoke(proxyPB, new object[] { });
            _pbOnEnable?.Invoke(proxyPB, new object[] { });
            
            _pbProxyToOriginal[proxyPB] = pb;
        }

        private void UpdatePBConfigs() {
            foreach ((var proxy, var original) in _pbProxyToOriginal)
            {
                if (proxy == null)
                {
                    ScheduleDelayedUpdate();
                    return;
                }
                
                if (!original.configHasUpdated) continue;
                original.configHasUpdated = false;
                
                proxy.integrationType = original.integrationType;
                proxy.endpointPosition = original.endpointPosition;
                proxy.multiChildType = original.multiChildType;
                proxy.pull = original.pull;
                proxy.pullCurve = original.pullCurve;
                proxy.spring = original.spring;
                proxy.springCurve = original.springCurve;
                proxy.stiffness = original.stiffness;
                proxy.stiffnessCurve = original.stiffnessCurve;
                proxy.gravity = original.gravity;
                proxy.gravityCurve = original.gravityCurve;
                proxy.gravityFalloff = original.gravityFalloff;
                proxy.gravityFalloffCurve = original.gravityFalloffCurve;
                proxy.immobileType = original.immobileType;
                proxy.immobile = original.immobile;
                proxy.immobileCurve = original.immobileCurve;
                proxy.allowCollision = original.allowCollision;
                proxy.radius = original.radius;
                proxy.radiusCurve = original.radiusCurve;
                proxy.limitType = original.limitType;
                proxy.maxAngleX = original.maxAngleX;
                proxy.maxAngleXCurve = original.maxAngleXCurve;
                proxy.maxAngleZ = original.maxAngleZ;
                proxy.maxAngleZCurve = original.maxAngleZCurve;
                proxy.limitRotation = original.limitRotation;
                proxy.limitRotationXCurve = original.limitRotationXCurve;
                proxy.limitRotationYCurve = original.limitRotationYCurve;
                proxy.limitRotationZCurve = original.limitRotationZCurve;
                proxy.maxStretch = original.maxStretch;
                proxy.maxStretchCurve = original.maxStretchCurve;
                proxy.maxSquish = original.maxSquish;
                proxy.maxSquishCurve = original.maxSquishCurve;
                proxy.stretchMotion = original.stretchMotion;
                proxy.stretchMotionCurve = original.stretchMotionCurve;
                proxy.isAnimated = true;
                proxy.configHasUpdated = true;
            }

            foreach ((var original, var proxy) in _pbOriginalToProxyColliders)
            {
                if (proxy == null)
                {
                    ScheduleDelayedUpdate();
                    return;
                }
                
                proxy.position = original.position;
                proxy.radius = original.radius;
                proxy.rotation = original.rotation;
                proxy.height = original.height;
                proxy.insideBounds = original.insideBounds;
                proxy.shapeType = original.shapeType;
                // TODO - handle changes to root bone
                proxy.UpdateShape();
            }
        }

        private void ResetPB()
        {
            EditorApplication.update -= UpdatePBConfigs;
            // Destroy all PBs initially
            foreach (var pb in _pbProxyToOriginal.Keys)
            {
                _pbOnDisable?.Invoke(pb, new object[] { });
                Object.DestroyImmediate(pb);
            }

            foreach (var collider in _pbOriginalToProxyColliders.Values)
            {
                PhysBoneManager.Inst?.RemoveCollider(collider);
                Object.DestroyImmediate(collider);
            }

            foreach (var bone in pbControlledBones)
            {
                bone.ResetPose();
            }

            pbControlledBones.Clear();
            _pbProxyToOriginal.Clear();
            _pbOriginalToProxyColliders.Clear();
        }

        private class GC
        {
            private readonly HashSet<BoneInfo> _liveBones = new();

            public bool IsLive(BoneInfo bone)
            {
                return _liveBones.Contains(bone);
            }

            public void MarkBone(BoneInfo bone)
            {
                var cursor = bone;
                while (cursor != null)
                {
                    if (_liveBones.Add(cursor))
                    {
                        cursor = cursor.Parent;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        private GC InitialMark()
        {
            GC gc = new();
            foreach (var bone in _shadowObjMap.Values)
            {
                if (bone.RefCount > 0)
                {
                    gc.MarkBone(bone);
                }
            }

            return gc;
        }

        private void SweepGC(GC gc)
        {
            // Sweep
            foreach (var bone in _shadowObjMap.Values
                         .Where(b => !gc.IsLive(b))
                         .OrderByDescending(b => b.Depth)
                         .ToList()
                    )
            {
                bone.Destroy();
            }
        }

        public void Dispose()
        {
            ResetPB();
            ResetConstraints();
            
            foreach ((var obj, var info) in _shadowObjMap.ToList())
            {
                if (obj != null)
                {
                    info.Destroy();
                }
            }
            
            _shadowObjMap.Clear();
            _sourceToShadowMap.Clear();
            _updateOrder = null;
            _delayedUpdatePending = false;
        }
    }
}