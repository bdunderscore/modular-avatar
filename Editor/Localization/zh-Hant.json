{
  "test0.test_a": "test_a",
  "test0.test_b": "test_b",
  "boneproxy.foldout.advanced": "進階設定",
  "boneproxy.target": "目標",
  "menuinstall.help.hint_set_menu": "此 Prefab 的選單預設會安裝到 Avatar 的頂部選單中。如果不需要，可以選擇其他選單或取消勾選此元件。",
  "menuinstall.help.hint_bad_menu": "選擇的選單不屬於此 Avatar。",
  "menuinstall.installto": "安裝到",
  "menuinstall.installto.tooltip": "當前 Prefab 的選單將會安裝到此選單",
  "menuinstall.selectmenu": "選擇選單",
  "menuinstall.showcontents": "顯示選單內容",
  "menuinstall.showcontents.notselected": "未選擇選單",
  "menuinstall.devoptions": "Prefab 開發者選項",
  "menuinstall.menu_icon_too_large": "選單圖示過大，圖示應小於 256 像素。",
  "menuinstall.menu_icon_uncompressed": "選單圖示未設定壓縮。",
  "menuinstall.srcmenu": "要安裝的選單",
  "params.syncmode.NotSynced": "僅 Animator（不同步）",
  "params.syncmode.Int": "Int",
  "params.syncmode.Float": "Float",
  "params.syncmode.Bool": "Bool",
  "params.syncmode.PhysBonesPrefix": "PB 前綴",
  "params.__comment__": "=== Unity 2019 only strings ===",
  "params.autodetect_header": "   自動檢測參數   ",
  "params.internal": "內部",
  "params.pb_prefix": "PhysBones 前綴",
  "params.syncmode": "參數類型",
  "params.saved": "保存",
  "params.synced": "同步",
  "params.default": "預設值",
  "params.fieldname": "字段名",
  "params.remapto": "字段名映射到",
  "params.remapto.tooltip": "輸入新的名稱以防止參數名稱衝突",
  "params.devmode": "顯示 Prefab 開發者選項",
  "params.__comment1__": "=== Unity 2022 only strings ===",
  "merge_parameter.ui.name": "參數名稱",
  "merge_parameter.ui.prefix": "PhysBone 前綴名稱",
  "merge_parameter.ui.remapTo": "將名稱更改為",
  "merge_parameter.ui.remapTo.tooltip": "在這裡輸入一個新名稱以重新命名此參數或前綴。這可以用來解決名稱衝突或連結多種功能模塊。",
  "merge_parameter.ui.remapTo.automatic": "（自動鎖定）",
  "merge_parameter.ui.defaultValue": "預設值",
  "merge_parameter.ui.defaultValue.tooltip": "首次使用或重置 Avatar 時，參數將被設定為此值",
  "merge_parameter.ui.saved": "保存",
  "merge_parameter.ui.saved.tooltip": "如果為打勾，更換 Avatar 或房間時，參數的值將被保存。",
  "merge_parameter.ui.internalParameter": "自動重命名",
  "merge_parameter.ui.internalParameter.tooltip": "如果為打勾，參數將會自動重命名以防止名稱和其他參數衝突",
  "merge_parameter.ui.isPrefix": "是 PhysBone 前綴",
  "merge_parameter.ui.syncType": "參數類型",
  "merge_parameter.ui.synced": "同步",
  "merge_parameter.ui.synced.tooltip": "如果為打勾，參數將會在網路上同步",
  "merge_parameter.ui.unregistered_foldout": "未註冊的參數",
  "merge_parameter.ui.add_button": "添加",
  "merge_parameter.ui.details": "參數設定",
  "merge_parameter.ui.overrideAnimatorDefaults": "覆蓋 Animator 預設值",
  "merge_armature.merge_target": "合併目標",
  "merge_armature.merge_target.tooltip": "當前物件要合併到的骨架（或其子級）",
  "merge_armature.prefix": "骨骼前綴",
  "merge_armature.prefix.tooltip": "當前物件裡要合併的骨骼的前綴",
  "merge_armature.suffix": "骨骼後綴",
  "merge_armature.suffix.tooltip": "當前物件裡要合併的骨骼的後綴",
  "merge_armature.locked": "鎖定位置",
  "merge_armature.locked.tooltip": "將當前物件的骨架與合併目標的骨架鎖定（反之亦然），常用於創建動畫。",
  "merge_armature.adjust_names": "根據合併目標調整骨骼名稱",
  "merge_armature.adjust_names.tooltip": "根據合併目標調整骨骼名稱，通常用於與非 Avatar 對應的服裝。",
  "merge_armature.mangle_names": "避免命名衝突",
  "merge_armature.mangle_names.tooltip": "通過重新命名新添加的骨骼來避免與其他資源發生命名衝突。",
  "path_mode.Relative": "相對路徑（基於當前物件）",
  "path_mode.Absolute": "絕對路徑（基於 Avatar 的根）",
  "merge_animator.animator": "要合併的 Animator",
  "merge_animator.layer_type": "Layer 類型",
  "merge_animator.delete_attached_animator": "刪除額外的 Animator",
  "merge_animator.delete_attached_animator.tooltip": "合併後刪除當前物件上的 Animator 元件",
  "merge_animator.path_mode": "路徑模式",
  "merge_animator.path_mode.tooltip": "在動畫中路徑的工作模式。\n使用相對路徑可以讓你在當前物件上錄制動畫。",
  "merge_animator.match_avatar_write_defaults": "配合 Avatar 的 Write Defaults 設定",
  "merge_animator.match_avatar_write_defaults.tooltip": "使用與 Avatar 一樣的 Write Defaults 設定。\n如果 Avatar 為 WD 混用，Animator 的 WD 設定將維持不變。",
  "merge_animator.relative_path_root": "相對路徑根物件",
  "merge_animator.relative_path_root.tooltip": "解析相對路徑時使用的根物件。\n如果未指定，則使用當前物件。",
  "merge_animator.layer_priority": "動畫層優先級",
  "merge_animator.layer_priority.tooltip": "控制動畫層合併後在 Animator 裡的位置，\n由小到大。負值將合併於原有動畫層之前，\n0 或正值將合併於之後。",
  "merge_armature.lockmode": "位置同步模式",
  "merge_armature.lockmode.not_locked.title": "不同步",
  "merge_armature.lockmode.not_locked.body": "當前物件的骨骼不會和 Avatar 的骨骼位置同步。",
  "merge_armature.lockmode.base_to_merge.title": "Avatar  =====> 物件（單向）",
  "merge_armature.lockmode.base_to_merge.body": "Avatar 骨骼位置改變，當前物件的骨骼也會改變。\n當前物件的骨骼位置改變，Avatar 骨骼不會改變。\n建議一般服裝使用此模式，因為此模式允許調整服裝的骨骼。",
  "merge_armature.lockmode.bidirectional.title": "Avatar <=====> 物件（雙向）",
  "merge_armature.lockmode.bidirectional.body": "Avatar 骨骼和當前物件的骨骼的位置始終相同。\n此模式對創建基於 Avatar 骨骼的動畫時非常有用。\n啟用此模式要求 Avatar 骨骼和當前物件的骨骼位置完全相同。",
  "merge_armature.reset_pos": "將位置與 Avatar 進行對齊",
  "merge_armature.reset_pos.info": "此命令將強制服裝骨骼與 Avatar 骨骼進行對齊，在使用非 Avatar 對應的服裝時可能有幫助。",
  "merge_armature.reset_pos.adjust_rotation": "也對齊旋轉",
  "merge_armature.reset_pos.adjust_scale": "也對齊縮放",
  "merge_armature.reset_pos.execute": "執行",
  "merge_armature.reset_pos.heuristic_scale": "根據 Avatar 調整服裝的整體比例",
  "merge_armature.reset_pos.heuristic_scale.tooltip": "以臂展作為參考，調整服裝的整體比例。\n推薦用於非 Avatar 對應的服裝。",
  "merge_blend_tree.blend_tree": "Blend Tree",
  "merge_blend_tree.path_mode": "路徑模式",
  "merge_blend_tree.path_mode.tooltip": "在動畫中路徑的工作模式。\n使用相對路徑可以讓你在當前物件上錄制動畫。",
  "merge_blend_tree.relative_path_root": "相對路徑根物件",
  "merge_blend_tree.relative_path_root.tooltip": "解析相對路徑時使用的根物件。\n如果未指定，則使用當前物件。",
  "worldfixed.quest": "此元件未生效，因為它與 Android 環境不相容。",
  "worldfixed.normal": "當前物件將會固定於世界，除非你使用約束將它綁在 Avatar 內。",
  "fpvisible.normal": "當前物件將在第一人稱視角中可見。",
  "fpvisible.quest": "此元件未生效，因為它與 Android 環境不相容。",
  "fpvisible.InPhysBoneChain": "當前物件由 Physics Bone 控制，可能無法在第一人稱視角中可見；請指定 Physics Bone 鏈的起點。",
  "blendshape.mesh": "網格",
  "blendshape.source": "源 blendshape",
  "blendshape.target": "當前網格的 blendshape",
  "hint.not_in_avatar": "此元件需要放置於你的 Avatar 內才能工作。",
  "boneproxy.err.MovingTarget": "你不能指定將由其他 Modular Avatar 元件移動的物件",
  "boneproxy.err.NotInAvatar": "你必須指定一個在 Avatar 內的物件",
  "boneproxy.attachment": "附加模式",
  "boneproxy.attachment.AsChildAtRoot": "作為子級，放置於 Root",
  "boneproxy.attachment.AsChildKeepWorldPose": "作為子級，保持原有位置和選轉",
  "boneproxy.attachment.AsChildKeepPosition": "作為子級，保持原有位置",
  "boneproxy.attachment.AsChildKeepRotation": "作為子級，保持原有旋轉",
  "mesh_settings.header_probe_anchor": "錨點覆蓋設定",
  "mesh_settings.inherit_probe_anchor": "錨點覆蓋模式",
  "mesh_settings.probe_anchor": "錨點覆蓋",
  "mesh_settings.probe_anchor.tooltip": "Anchor Override，\n設定用於當前物件和子物件內的渲染器的錨點覆蓋",
  "mesh_settings.header_bounds": "網格邊界設定",
  "mesh_settings.inherit_bounds": "網格邊界模式",
  "mesh_settings.root_bone": "根骨骼",
  "mesh_settings.root_bone.tooltip": "網格的根骨骼（Root bone），\n這被用作計算網格邊界的參考點。",
  "mesh_settings.bounds": "網格邊界",
  "mesh_settings.bounds.tooltip": "網格的邊界（Bounds），\n用於確定何時要略過螢幕外的網格渲染。",
  "mesh_settings.inherit_mode.Inherit": "繼承",
  "mesh_settings.inherit_mode.Set": "指定",
  "mesh_settings.inherit_mode.DontSet": "保持原設定",
  "mesh_settings.inherit_mode.SetOrInherit": "父級設定優先，否則指定",
  "pb_blocker.help": "當前物件不會受到附加在父物件的 PhysBones 影響。",
  "hint.bad_vrcsdk": "檢測到不相容的 VRCSDK 版本。\n\n請嘗試升級 VRCSDK；如果這不起作用，請嘗試新版本的 Modular Avatar。",
  "error.stack_trace": "Stack trace（報告錯誤時請提供此資訊！）",
  "error.merge_armature.circular_dependency": "[MA-0001] 在 Merge armature 中存在循環引用",
  "error.merge_armature.circular_dependency:description": "你的 Merge Armature 元件正在將自身或其子級作為合併目標。",
  "error.merge_armature.circular_dependency:hint": "通常應在 Merge Armature 的合併目標欄位指定 Avatar 本身的 Armture。不要指定服裝本身！",
  "error.merge_armature.physbone_on_humanoid_bone": "[MA-0002] 在 Humanoid 骨骼上有 PhysBones 元件",
  "error.merge_armature.physbone_on_humanoid_bone:hint": "在要合併的骨架中，某些 Humanoid 骨骼受到 PhysBones 控制，其位置與合併目標中相應的 Humanoid 骨骼不同。你應該在要合併的骨架中，移除這些 Humanoid 骨骼上的 PhysBones。",
  "error.merge_blend_tree.missing_tree": "[MA-0009] 未指定 Blend Tree",
  "error.merge_blend_tree.missing_tree:hint": "Merge Blend Tree 需要知道要合併到哪個 Blend Tree。請嘗試在「Blend Tree」中設定一個物件。",
  "error.internal_error": "[MA-9999] 發生內部錯誤：{0}\nwhen processing:",
  "error.merge_animator.param_type_mismatch": "[MA-0003] 參數類型不符",
  "error.merge_animator.param_type_mismatch:description": "參數 {0} 具有多種類型：{1} != {2}",
  "error.rename_params.too_many_synced_params": "太多同步參數：Cost {0} > {1}",
  "error.rename_params.too_many_synced_params:description": "在你的 Avatar 中有太多同步參數。你已使用 {0} bits 的參數，但限制為 {1}。",
  "error.rename_params.type_conflict": "[MA-0006] 參數類型衝突",
  "error.rename_params.type_conflict:description": "參數 {0} 指定了多種類型：{1} != {2}",
  "error.rename_params.default_value_conflict": "[MA-0007] 預設值衝突",
  "error.rename_params.default_value_conflict:description": "參數 {0} 指定了多個預設值：{1} != {2}",
  "error.rename_params.default_value_conflict:hint": "為了避免不可預測的行為，請將 MA Parameters 元件中所有預設值留空，只留一個。如果存在多個值，Modular Avatar 將選擇第一個預設值。",
  "error.replace_object.null_target": "[MA-0008] 未指定要替換的物件",
  "error.replace_object.null_target:hint": "Replace object 需要知道要替換掉哪個物件。嘗試指定一個。",
  "validation.blendshape_sync.no_local_renderer": "[MA-1000] 在此物件上找不到 Renderer",
  "validation.blendshape_sync.no_local_renderer:hint": "Blendshape Sync 作用於所在物件上的 Skinned Mesh Renderer。你是否將它附加到正確的物件上？",
  "validation.blendshape_sync.no_local_mesh": "[MA-1001] 在此物件的 Renderer 上找不到網格（Mesh）",
  "validation.blendshape_sync.no_local_mesh:hint": "當前物件上的 Skinned Mesh Renderer 配置可能有問題。請嘗試從原 Prefab 或 FBX 重新設定物件。",
  "validation.blendshape_sync.no_bindings": "[MA-1002] 在此物件上找不到 BlendShape",
  "validation.blendshape_sync.no_bindings:hint": "Blendshape Sync 需要知道要同步哪些 blendshape。點擊「+」新增。",
  "validation.blendshape_sync.missing_local_shape": "[MA-1003] 找不到當前網格的 BlendShape：「{0}」",
  "validation.blendshape_sync.missing_local_shape:description": "找不到當前網格的 BlendShape：{0}",
  "validation.blendshape_sync.missing_local_shape:hint": "找不到從「接收」數值的 BlendShape。請更換成被標紅的 Blendshape。",
  "validation.blendshape_sync.missing_target_shape": "[MA-1004] 找不到源 BlendShape：「{0}」",
  "validation.blendshape_sync.missing_target_shape:description": "找不到源 BlendShape：{0}",
  "validation.blendshape_sync.missing_target_shape:hint": "找不到向當前物件「發送」數值的 BlendShape。請更換被標紅的 Blendshape。",
  "validation.blendshape_sync.no_target": "[MA-1005] 未指定目標物件（網格）",
  "validation.blendshape_sync.no_target:hint": "Blendshape Sync 需要知道要從哪個物件那同步 Blendshape。請在「網格」中指定。",
  "validation.blendshape_sync.missing_target_renderer": "[MA-1006] 在目標物件上找不到 Renderer",
  "validation.blendshape_sync.missing_target_renderer:hint": "Blendshape Sync 會從目標物件上的 Skinned Mesh Renderer 接收 blendshape 的值。你是否將它附加到正確的物件上？",
  "validation.blendshape_sync.missing_target_mesh": "[MA-1007] 在目標物件的 Renderer 上找不到網格（Mesh）",
  "validation.blendshape_sync.missing_target_mesh:hint": "目標物件上的 Skinned Mesh Renderer 配置可能有問題。請嘗試從原 Prefab 或 FBX 重新設定對象。",
  "validation.bone_proxy.no_target": "[MA-1100] 未指定目標物件，或未找到目標物件",
  "validation.bone_proxy.no_target:hint": "Bone Proxy 需要知道要將當前物件綁定到哪個物件。請在「目標」中指定。",
  "validation.menu_installer.no_menu": "[MA-1200] 未指定要安裝的選單",
  "validation.menu_installer.no_menu:hint": "Menu Installer 需要知道要安裝哪個選單。請在「Prefab 開發者選項」裡「要安裝的選單」指定，或是新增一個「MA Menu Item」元件。",
  "validation.merge_animator.no_animator": "[MA-1300] 未指定要合併的 Animator",
  "validation.merge_animator.no_animator:hint": "Merge Animator 需要知道要合併哪個 Animator。請在「要合併的 Animator」中指定。",
  "validation.merge_armature.no_target": "[MA-1400] 未指定合併目標",
  "validation.merge_armature.no_target:hint": "Merge Armature 需要知道要合併到哪個骨架裡。請在「合併目標」中指定。",
  "validation.merge_armature.target_is_child": "[MA-1500] 合併目標不能是此物件的子級",
  "validation.merge_armature.target_is_child:hint": "Merge Armature 不能合併骨架到其自身。請將「合併目標」設定為其他物件。",
  "submenu_source.Children": "子物件",
  "submenu_source.MenuAsset": "角色控制選單資源 (Expressions Menu)",
  "menuitem.showcontents": "顯示選單內容",
  "menuitem.prop.name": "名稱",
  "menuitem.prop.icon": "圖示",
  "menuitem.prop.icon.tooltip": "（可選）在角色控制選單中顯示的圖示",
  "menuitem.prop.type": "類型",
  "menuitem.prop.type.tooltip": "此選單項的類型",
  "menuitem.prop.value": "參數值",
  "menuitem.prop.value.tooltip": "設定選單項觸發時的參數值",
  "menuitem.prop.automatic_value": "自動",
  "menuitem.prop.parameter": "參數",
  "menuitem.prop.label": "名稱",
  "menuitem.prop.submenu_asset": "子選單資源",
  "menuitem.prop.submenu_asset.tooltip": "用作子選單的資源文件",
  "menuitem.prop.submenu_source": "子選單來源",
  "menuitem.prop.submenu_source.tooltip": "尋找子選單的選單項的方式",
  "menuitem.prop.source_override": "源物件",
  "menuitem.prop.source_override.tooltip": "如果指定，這個物件將被用作子選單內容的來源。\n否則，將使用此選單項的子級。",
  "menuitem.prop.is_default": "預設啟用",
  "menuitem.prop.is_default.tooltip": "如果打勾，初次使用或重置 Avatar 時會啟用此選單項",
  "menuitem.prop.is_saved": "保存",
  "menuitem.prop.is_saved.tooltip": "如果打勾，當您更換 Avatar 或房間時，此選單項的值將被保存。",
  "menuitem.prop.is_synced": "同步",
  "menuitem.prop.is_synced.tooltip": "如果打勾，此選單項的值將和網路上的其他玩家同步。",
  "menuitem.param.rotation": "參數: 旋轉 (Rotation)",
  "menuitem.param.rotation.tooltip": "基於此選單項的旋轉設定的參數。",
  "menuitem.param.horizontal": "參數: 水平 (Horizontal)",
  "menuitem.param.horizontal.tooltip": "基於搖桿的水平位置設定的參數。",
  "menuitem.param.vertical": "參數: 垂直 (Vertical)",
  "menuitem.param.vertical.tooltip": "基於搖桿的垂直位置設定的參數。",
  "menuitem.label.control_labels_and_params": "設定名稱和參數",
  "menuitem.label.control_labels": "設定名稱",
  "menuitem.misc.multiple": "（複數設定）",
  "menuitem.misc.no_icon": "（無圖示）",
  "menuitem.misc.extract": "提取為物件",
  "menuitem.label.parameters": "參數",
  "action.toggle_object.header.object": "要顯示 / 隱藏的物件",
  "action.toggle_object.header.show": "顯示",
  "menu_tree.title": "選擇選單",
  "menuitem.param.controlled_by_action": "< 由 Action 控制 >",
  "control_group.foldout.actions": "Actions",
  "control_group.foldout.menu_items": "相關選單項",
  "control_group.is_saved": "保存",
  "control_group.is_saved.tooltip": "如果打勾，當您更換 Avatar 或世界時，此選單項的值將被保存。",
  "control_group.is_synced": "同步",
  "control_group.is_synced.tooltip": "如果打勾，此選單項的值將和網路上的其他玩家同步。",
  "control_group.default_value": "初始設定",
  "control_group.default_value.unset": "（未選擇）",
  "animation_gen.duplicate_binding": "來自不同控制群組的控制項嘗試動畫相同的參數。參數：{0}",
  "animation_gen.multiple_defaults": "在同一個控制群組中找到多個默認的選單項。",
  "menuitem.misc.add_item": "添加選單項",
  "replace_object.target_object": "要替換的物件",
  "setup_outfit.err.header.notarget": "Setup Outfit 失敗",
  "setup_outfit.err.header": "對 {0} 進行 Setup Outfit 失敗",
  "setup_outfit.err.unknown": "未知錯誤",
  "setup_outfit.err.no_selection": "沒有選擇物件。",
  "setup_outfit.err.run_on_avatar_itself": "Setup outfit 必須在服裝物件上運行，而不是在 Avatar 本身。\n\n你是要製作「混種 Avatar」嗎？如果是，請從「裡 Avatar」中移除 Avatar descriptor 元件，然後對其執行 Setup outfit。",
  "setup_outfit.err.multiple_avatar_descriptors": "在 {0} 和其父級中有多個 Avatar descriptor。\n\n你是要製作「混種 Avatar」嗎？如果是，請從「裡 Avatar」中移除 Avatar descriptor 元件，然後對其執行 Setup outfit。",
  "setup_outfit.err.no_avatar_descriptor": "在 {0} 的父級中找不到 VRC Avatar Descriptor。請確保你的服裝放置在 Avatar 裡。",
  "setup_outfit.err.no_animator": "你的 Avatar 沒有 Animator 元件。",
  "setup_outfit.err.no_hips": "你的 Avatar 沒有 Hips 骨骼。Setup Outfit 只能用於 humanoid Avatars。",
  "move_independently.group-header": "要一起移動的物件",
  "scale_adjuster.scale": "調整比例",
  "scale_adjuster.adjust_children": "調整子級的位置",
  "world_fixed_object.err.unsupported_platform": "此平台不支援 World Fixed Object 元件。",
  "world_fixed_object.err.unsupported_platform:description": "此元件未生效。因為在 Android 環境下不支援 World Fixed Object。",
  "ma_info.param_usage_ui.header": "Expressions 的參數使用狀況",
  "ma_info.param_usage_ui.other_objects": "此 Avatar 中的其他東西",
  "ma_info.param_usage_ui.free_space": "未使用的參數空間 ({0} bits)",
  "ma_info.param_usage_ui.bits_template": "{0} ({1} bits)",
  "ma_info.param_usage_ui.no_data": "【無資訊】",
  "reactive_object.inverse": "反轉條件",
  "reactive_object.material-setter.set-to": "將材質設定為：",
  "menuitem.misc.add_toggle": "新增開關",
  "ro_sim.open_debugger_button": "開啟 Reaction 除錯工具",
  "ro_sim.window.title": "MA 響應除錯工具",
  "ro_sim.header.inspecting": "檢視物件",
  "ro_sim.header.clear_overrides": "清除所有覆寫",
  "ro_sim.header.object_state": "物件狀態",
  "ro_sim.state.active": "啟用",
  "ro_sim.state.inactive": "停用",
  "ro_sim.header.override_gameobject_state": "覆寫物件狀態",
  "ro_sim.header.override_menuitem_state": "覆寫選單項狀態",
  "ro_sim.affected_by.title": "受到以下影響：",
  "ro_sim.effect_group.controls_obj_state": "控制物件狀態為：",
  "ro_sim.effect_group.target_component": "目標元件",
  "ro_sim.effect_group.target_component.tooltip": "受到 Reactive Component 影響的元件",
  "ro_sim.effect_group.property": "屬性",
  "ro_sim.effect_group.property.tooltip": "受到 Reactive Component 影響的目標元件屬性",
  "ro_sim.effect_group.value": "值",
  "ro_sim.effect_group.value.tooltip": "Reactive Component 啟用時，屬性將被設為此值",
  "ro_sim.effect_group.material": "材質",
  "ro_sim.effect_group.material.tooltip": "Reactive Component 啟用時，將被設在目標元件上的材質",
  "ro_sim.effect_group.rule_inverted": "規則的條件已反轉",
  "ro_sim.effect_group.rule_inverted.tooltip": "這條規則將在未達成其任一條件時套用。",
  "ro_sim.effect_group.conditions": "條件"
}
